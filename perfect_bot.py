import requests
import json
import time
import os
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes
from flask import Flask, render_template_string, request
from werkzeug.security import check_password_hash, generate_password_hash

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(filename='bot.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN', 'YOUR_BOT_TOKEN_HERE')  # –¢–æ–∫–µ–Ω –æ—Ç BotFather
CRYPTO_PAY_TOKEN = os.getenv('CRYPTO_PAY_TOKEN', 'YOUR_CRYPTO_PAY_TOKEN')  # –¢–æ–∫–µ–Ω –æ—Ç @Send
ADMIN_PASSWORD_HASH = generate_password_hash('trust20242024')  # –ü–∞—Ä–æ–ª—å –¥–ª—è –¥–∞—à–±–æ—Ä–¥–∞ (–∑–∞–º–µ–Ω–∏)
AD_MESSAGE = "\n\nüì¢ –†–µ–∫–ª–∞–º–∞: –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –º–æ–π –∫–∞–Ω–∞–ª @YourChannel –¥–ª—è –Ω–æ–≤–æ—Å—Ç–µ–π –æ –∫—Ä–∏–ø—Ç–µ –∏ —Ñ–∏–Ω–∞–Ω—Å–∞—Ö!"
FREE_REQUEST_LIMIT = 10  # –õ–∏–º–∏—Ç –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ —Å—É—Ç–∫–∏
SUBSCRIPTION_PRICE = 5  # –¶–µ–Ω–∞ –ø–æ–¥–ø–∏—Å–∫–∏ –≤ USDT

# –°–ª–æ–≤–∞—Ä–∏ –≤–∞–ª—é—Ç (–∫–æ–¥—ã –¥–ª—è CoinGecko)
CURRENCIES = {
    '–¥–æ–ª–ª–∞—Ä': 'USD', '–¥–æ–ª–ª–∞—Ä—ã': 'USD', '–¥–æ–ª–ª–∞—Ä–∞': 'USD', 'usd': 'USD',
    '–≥—Ä–∏–≤–Ω–∞': 'UAH', '–≥—Ä–∏–≤–Ω—ã': 'UAH', '–≥—Ä–∏–≤–µ–Ω': 'UAH', 'uah': 'UAH',
    '–µ–≤—Ä–æ': 'EUR', 'eur': 'EUR',
    '—Ä—É–±–ª—å': 'RUB', '—Ä—É–±–ª–∏': 'RUB', '—Ä—É–±–ª—è': 'RUB', 'rub': 'RUB',
    '–π–µ–Ω–∞': 'JPY', '–π–µ–Ω—ã': 'JPY', 'jpy': 'JPY',
    '—é–∞–Ω—å': 'CNY', '—é–∞–Ω–∏': 'CNY', 'cny': 'CNY',
    '—Ñ—É–Ω—Ç': 'GBP', '—Ñ—É–Ω—Ç—ã': 'GBP', 'gbp': 'GBP',
    '–±–∏—Ç–∫–æ–∏–Ω': 'bitcoin', '–±–∏—Ç–∫–æ–∏–Ω—ã': 'bitcoin', '–±–∏—Ç–∫–æ–∏–Ω–∞': 'bitcoin', 'btc': 'bitcoin',
    '—ç—Ñ–∏—Ä': 'ethereum', '—ç—Ñ–∏—Ä–∏—É–º': 'ethereum', '—ç—Ñ–∏—Ä–∞': 'ethereum', 'eth': 'ethereum',
    '—Ä–∏–ø–ª': 'ripple', '—Ä–∏–ø–ª—ã': 'ripple', 'xrp': 'ripple',
    '–¥–æ–≥–µ–∫–æ–∏–Ω': 'dogecoin', '–¥–æ–≥–µ': 'dogecoin', '–¥–æ–≥–µ–∫–æ–∏–Ω–∞': 'dogecoin', 'doge': 'dogecoin',
    '–∫–∞—Ä–¥–∞–Ω–æ': 'cardano', '–∫–∞—Ä–¥–∞–Ω—ã': 'cardano', 'ada': 'cardano',
    '—Å–æ–ª–∞–Ω–∞': 'solana', '—Å–æ–ª–∞–Ω—ã': 'solana', 'sol': 'solana',
    '–ª–∞–π—Ç–∫–æ–∏–Ω': 'litecoin', '–ª–∞–π—Ç–∫–æ–∏–Ω—ã': 'litecoin', 'ltc': 'litecoin'
}

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
CACHE = {}  # –ö—ç—à –∫—É—Ä—Å–æ–≤ –≤–∞–ª—é—Ç
CACHE_TIMEOUT = 300  # 5 –º–∏–Ω—É—Ç
STATS = {
    "users": {},
    "total_requests": 0,
    "request_types": {},
    "subscriptions": {},
    "revenue": 0.0
}

def save_stats(user_id, request_type):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∑–∞–ø—Ä–æ—Å–æ–≤"""
    current_day = time.strftime("%Y-%m-%d")
    if user_id not in STATS["users"]:
        STATS["users"][user_id] = {"requests": 0, "last_reset": current_day}
    
    user_data = STATS["users"][user_id]
    if user_data["last_reset"] != current_day:
        user_data["requests"] = 0
        user_data["last_reset"] = current_day
    
    user_data["requests"] += 1
    STATS["total_requests"] += 1
    STATS["request_types"][request_type] = STATS["request_types"].get(request_type, 0) + 1
    logger.info(f"Stats updated for user {user_id}: {request_type}")

def get_stats():
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¥–ª—è –¥–∞—à–±–æ—Ä–¥–∞"""
    total_users = len(STATS["users"])
    total_requests = STATS["total_requests"]
    popular_requests = sorted(STATS["request_types"].items(), key=lambda x: x[1], reverse=True)[:5]
    subscriptions = len(STATS["subscriptions"])
    revenue = STATS["revenue"]
    return total_users, total_requests, popular_requests, subscriptions, revenue

def check_limit(user_id):
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    subscribed = STATS["subscriptions"].get(user_id, False)
    if subscribed:
        return True
    user_data = STATS["users"].get(user_id, {"requests": 0, "last_reset": time.strftime("%Y-%m-%d")})
    return user_data["requests"] < FREE_REQUEST_LIMIT

def get_exchange_rate(from_currency, to_currency, amount=1):
    """–ü–æ–ª—É—á–∞–µ—Ç –∫—É—Ä—Å –≤–∞–ª—é—Ç —á–µ—Ä–µ–∑ CoinGecko"""
    from_key = from_currency.lower()
    to_key = to_currency.lower()
    cache_key = f"{from_key}_{to_key}"
    
    if cache_key in CACHE and time.time() - CACHE[cache_key]['timestamp'] < CACHE_TIMEOUT:
        rate = CACHE[cache_key]['rate']
        logger.info(f"Using cached rate for {from_key} to {to_key}: {rate}")
        return amount * rate, rate
    
    from_code = CURRENCIES.get(from_key)
    to_code = CURRENCIES.get(to_key)
    
    if not from_code or not to_code:
        logger.error(f"Invalid currency codes: {from_key} -> {to_key}")
        return None, "–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–∞—è –≤–∞–ª—é—Ç–∞."
    
    try:
        url = f"https://api.coingecko.com/api/v3/simple/price?ids={from_code}&vs_currencies={to_code}"
        response = requests.get(url, timeout=5).json()
        logger.info(f"API response for {from_code} to {to_code}: {response}")
        
        if from_code in response and to_code.lower() in response[from_code]:
            rate = response[from_code][to_code.lower()]
            if rate == 0:
                logger.error(f"Zero rate returned for {from_code} to {to_code}")
                return None, "–ö—É—Ä—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (–Ω—É–ª–µ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ)."
            result = amount * rate
            CACHE[cache_key] = {'rate': rate, 'timestamp': time.time()}
            return result, rate
        else:
            logger.error(f"No valid rate in response for {from_code} to {to_code}")
            return None, "–ö—É—Ä—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω."
    except Exception as e:
        logger.error(f"Error fetching rate for {from_code} to {to_code}: {e}")
        return None, "–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫—É—Ä—Å–∞."

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
    user_id = str(update.message.from_user.id)
    save_stats(user_id, "start")
    logger.info(f"User {user_id} started bot")
    await update.message.reply_text(
        '–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –≤–∞–ª—é—Ç.\n'
        '–ò—Å–ø–æ–ª—å–∑—É–π /kurs, –Ω–∞–ø—Ä–∏–º–µ—Ä: "/kurs usd btc" –∏–ª–∏ "/kurs 44 –¥–æ–ª–ª–∞—Ä–∞ –∫ —ç—Ñ–∏—Ä—É".\n'
        f'–ë–µ—Å–ø–ª–∞—Ç–Ω–æ ‚Äî {FREE_REQUEST_LIMIT} –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ —Å—É—Ç–∫–∏.\n'
        f'–î–ª—è –±–µ–∑–ª–∏–º–∏—Ç–∞ ‚Äî /subscribe –∑–∞ {SUBSCRIPTION_PRICE} USDT.'
    )

async def subscribe(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /subscribe"""
    user_id = str(update.message.from_user.id)
    if STATS["subscriptions"].get(user_id, False):
        logger.info(f"User {user_id} already subscribed")
        await update.message.reply_text("–¢—ã —É–∂–µ –ø–æ–¥–ø–∏—Å–∞–Ω –Ω–∞ –±–µ–∑–ª–∏–º–∏—Ç!")
        return
    
    headers = {'Crypto-Pay-API-Token': CRYPTO_PAY_TOKEN}
    payload = {
        "amount": str(SUBSCRIPTION_PRICE),
        "currency": "USDT",
        "description": f"–ë–µ–∑–ª–∏–º–∏—Ç–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞ –¥–ª—è {user_id}"
    }
    try:
        response = requests.post("https://pay.crypt.bot/api/createInvoice", headers=headers, json=payload).json()
        logger.info(f"Invoice request for {user_id}: {response}")
        if response.get("ok"):
            invoice_id = response["result"]["invoice_id"]
            pay_url = response["result"]["pay_url"]
            keyboard = [[InlineKeyboardButton(f"–û–ø–ª–∞—Ç–∏—Ç—å {SUBSCRIPTION_PRICE} USDT", url=pay_url)]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            context.user_data[user_id] = {"invoice_id": invoice_id}
            await update.message.reply_text(f"–û–ø–ª–∞—Ç–∏ {SUBSCRIPTION_PRICE} USDT –¥–ª—è –±–µ–∑–ª–∏–º–∏—Ç–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞:", reply_markup=reply_markup)
        else:
            logger.error(f"Invoice failed for {user_id}: {response.get('error', 'Unknown error')}")
            await update.message.reply_text(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞: {response.get('error', '–ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.')}")
    except Exception as e:
        logger.error(f"Exception in subscribe for {user_id}: {e}")
        await update.message.reply_text("–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ø–ª–∞—Ç–µ–∂–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ. –ü—Ä–æ–≤–µ—Ä—å —Ç–æ–∫–µ–Ω –∏–ª–∏ –ø–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.")

async def check_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /check"""
    user_id = str(update.message.from_user.id)
    if user_id not in context.user_data or "invoice_id" not in context.user_data[user_id]:
        await update.message.reply_text("–°–Ω–∞—á–∞–ª–∞ –∑–∞–ø—Ä–æ—Å–∏ –ø–æ–¥–ø–∏—Å–∫—É —á–µ—Ä–µ–∑ /subscribe!")
        return
    
    invoice_id = context.user_data[user_id]["invoice_id"]
    headers = {'Crypto-Pay-API-Token': CRYPTO_PAY_TOKEN}
    try:
        response = requests.get(f"https://pay.crypt.bot/api/getInvoices?invoice_ids={invoice_id}", headers=headers).json()
        logger.info(f"Payment check for {user_id}: {response}")
        if response.get("ok") and response["result"]["items"]:
            status = response["result"]["items"][0]["status"]
            if status == "paid":
                STATS["subscriptions"][user_id] = True
                STATS["revenue"] += SUBSCRIPTION_PRICE
                del context.user_data[user_id]
                logger.info(f"Payment confirmed for {user_id}")
                await update.message.reply_text("–û–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞! –¢–µ–ø–µ—Ä—å —É —Ç–µ–±—è –±–µ–∑–ª–∏–º–∏—Ç.")
            else:
                await update.message.reply_text(f"–û–ø–ª–∞—Ç–∞ –µ—â—ë –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞. –°—Ç–∞—Ç—É—Å: {status}. –ü—Ä–æ–≤–µ—Ä—å –≤ @Send.")
        else:
            logger.error(f"Payment check failed for {user_id}: {response.get('error', 'Unknown error')}")
            await update.message.reply_text("–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ–ø–ª–∞—Ç—ã.")
    except Exception as e:
        logger.error(f"Exception in check_payment for {user_id}: {e}")
        await update.message.reply_text("–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏. –ü—Ä–æ–≤–µ—Ä—å —Ç–æ–∫–µ–Ω –∏–ª–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ.")

async def kurs_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /kurs"""
    user_id = str(update.message.from_user.id)
    args = context.args
    
    if not check_limit(user_id):
        await update.message.reply_text(f"–¢—ã –ø—Ä–µ–≤—ã—Å–∏–ª –ª–∏–º–∏—Ç {FREE_REQUEST_LIMIT} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ —Å—É—Ç–∫–∏. –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –±–µ–∑–ª–∏–º–∏—Ç –∑–∞ {SUBSCRIPTION_PRICE} USDT: /subscribe")
        return
    
    if not args:
        await update.message.reply_text('–ù–∞–ø–∏—à–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä: "/kurs usd btc" –∏–ª–∏ "/kurs 44 –¥–æ–ª–ª–∞—Ä–∞ –∫ —ç—Ñ–∏—Ä—É".')
        return
    
    text = " ".join(args).lower()
    parts = text.split()
    logger.info(f"User {user_id} requested kurs: {text}")
    
    try:
        if '–∫' in parts:
            k_index = parts.index('–∫')
            amount_part = parts[:k_index]
            from_part = parts[k_index-1]
            to_part = " ".join(parts[k_index+1:])
            amount = float(amount_part[0]) if amount_part and amount_part[0].replace('.', '', 1).isdigit() else 1
            from_currency = from_part
            to_currency = to_part
        else:
            if len(parts) >= 2 and parts[0].replace('.', '', 1).isdigit():
                amount = float(parts[0])
                from_currency, to_currency = parts[1], parts[2]
            else:
                amount = 1
                from_currency, to_currency = parts[0], parts[1]
        
        save_stats(user_id, f"{from_currency}_to_{to_currency}")
        result, rate = get_exchange_rate(from_currency, to_currency, amount)
        
        if result:
            remaining = FREE_REQUEST_LIMIT - STATS["users"][user_id]["requests"] if not STATS["subscriptions"].get(user_id, False) else "‚àû"
            response = f"{amount} {from_currency.upper()} = {result:.6f} {to_currency.upper()}\n–ö—É—Ä—Å: 1 {from_currency.upper()} = {rate:.6f} {to_currency.upper()}\n–û—Å—Ç–∞–ª–æ—Å—å –∑–∞–ø—Ä–æ—Å–æ–≤ —Å–µ–≥–æ–¥–Ω—è: {remaining}{AD_MESSAGE}"
            await update.message.reply_text(response)
        else:
            await update.message.reply_text(f"–û—à–∏–±–∫–∞: {rate}")
    except Exception as e:
        logger.error(f"Error in kurs for {user_id}: {e}")
        await update.message.reply_text('–ù–µ –ø–æ–Ω—è–ª –∑–∞–ø—Ä–æ—Å. –ü—Ä–∏–º–µ—Ä—ã: "/kurs usd btc" –∏–ª–∏ "/kurs 44 –¥–æ–ª–ª–∞—Ä–∞ –∫ —ç—Ñ–∏—Ä—É".')

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
    user_id = str(update.message.from_user.id)
    current_time = time.time()
    
    if 'last_request' in context.user_data and current_time - context.user_data['last_request'] < 1:
        await update.message.reply_text('–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤! –ü–æ–¥–æ–∂–¥–∏ —Å–µ–∫—É–Ω–¥—É.')
        return
    
    if not check_limit(user_id):
        await update.message.reply_text(f"–¢—ã –ø—Ä–µ–≤—ã—Å–∏–ª –ª–∏–º–∏—Ç {FREE_REQUEST_LIMIT} –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ —Å—É—Ç–∫–∏. –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –±–µ–∑–ª–∏–º–∏—Ç –∑–∞ {SUBSCRIPTION_PRICE} USDT: /subscribe")
        return
    
    context.user_data['last_request'] = current_time
    text = update.message.text.lower()
    logger.info(f"User {user_id} sent message: {text}")
    
    try:
        parts = text.split()
        amount = float(parts[0])
        from_currency = parts[1]
        if '–≤' in parts or 'to' in parts:
            to_currency = parts[-1]
        else:
            raise ValueError
        
        save_stats(user_id, f"{from_currency}_to_{to_currency}")
        result, rate = get_exchange_rate(from_currency, to_currency, amount)
        if result:
            remaining = FREE_REQUEST_LIMIT - STATS["users"][user_id]["requests"] if not STATS["subscriptions"].get(user_id, False) else "‚àû"
            response = f"{amount} {from_currency.upper()} = {result:.6f} {to_currency.upper()}\n–ö—É—Ä—Å: 1 {from_currency.upper()} = {rate:.6f} {to_currency.upper()}\n–û—Å—Ç–∞–ª–æ—Å—å –∑–∞–ø—Ä–æ—Å–æ–≤ —Å–µ–≥–æ–¥–Ω—è: {remaining}{AD_MESSAGE}"
            await update.message.reply_text(response)
        else:
            await update.message.reply_text(f"–û—à–∏–±–∫–∞: {rate}")
    except Exception as e:
        logger.error(f"Error in handle_message for {user_id}: {e}")

# Flask –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–ª—è –¥–∞—à–±–æ—Ä–¥–∞
app = Flask(__name__)

@app.route('/', methods=['GET', 'POST'])
def dashboard():
    """–í–µ–±-–¥–∞—à–±–æ—Ä–¥ —Å –ø–∞—Ä–æ–ª–µ–º"""
    if request.method == 'POST':
        password = request.form.get('password')
        if not check_password_hash(ADMIN_PASSWORD_HASH, password):
            return "–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å!", 403
    
    total_users, total_requests, popular_requests, subscriptions, revenue = get_stats()
    html = """
    <html>
        <head>
            <title>–î–∞—à–±–æ—Ä–¥ –±–æ—Ç–∞</title>
            <meta http-equiv="refresh" content="30">
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; background: #f4f4f4; }
                h1 { color: #333; }
                .stat { background: white; padding: 15px; margin: 10px 0; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
            </style>
        </head>
        <body>
            <h1>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ç–≤–æ–µ–≥–æ –±–æ—Ç–∞</h1>
            <div class="stat">–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {{ total_users }}</div>
            <div class="stat">–í—Å–µ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤: {{ total_requests }}</div>
            <div class="stat">–ü–æ–¥–ø–∏—Å–æ–∫: {{ subscriptions }}</div>
            <div class="stat">–î–æ—Ö–æ–¥: {{ revenue }} USDT</div>
            <div class="stat">
                <h3>–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã:</h3>
                <ul>
                    {% for req, count in popular_requests %}
                        <li>{{ req }}: {{ count }} —Ä–∞–∑</li>
                    {% endfor %}
                </ul>
            </div>
            {% if not password_entered %}
                <form method="post">
                    <input type="password" name="password" placeholder="–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å">
                    <input type="submit" value="–í–æ–π—Ç–∏">
                </form>
            {% endif %}
        </body>
    </html>
    """
    return render_template_string(html, total_users=total_users, total_requests=total_requests, 
                                 popular_requests=popular_requests, subscriptions=subscriptions, 
                                 revenue=revenue, password_entered='password' in request.form)

# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –∏ Flask
port = int(os.getenv("PORT", 5000))
application = Application.builder().token(TELEGRAM_TOKEN).build()
application.add_handler(CommandHandler("start", start))
application.add_handler(CommandHandler("kurs", kurs_command))
application.add_handler(CommandHandler("subscribe", subscribe))
application.add_handler(CommandHandler("check", check_payment))
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

def run_flask():
    app.run(host="0.0.0.0", port=port, use_reloader=False)

if __name__ == "__main__":
    import threading
    flask_thread = threading.Thread(target=run_flask)
    flask_thread.start()
    application.run_polling()
