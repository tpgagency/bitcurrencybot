import os
import json
import time
import logging
import requests
from telegram import Update, Bot, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes
import redis
from telegram.error import NetworkError, RetryAfter, TelegramError
from collections import deque
from telegram.constants import ParseMode

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å –∑–∞–ø–∏—Å—å—é –≤ —Ñ–∞–π–ª –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –∞–Ω–∞–ª–∏–∑–∞
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),  # –õ–æ–≥–∏ –≤ –∫–æ–Ω—Å–æ–ª—å
        logging.FileHandler('bot.log')  # –õ–æ–≥–∏ –≤ —Ñ–∞–π–ª –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
    ]
)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è (—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π, –Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω—ã –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏)
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN')
CRYPTO_PAY_TOKEN = os.getenv('CRYPTO_PAY_TOKEN')
REDIS_URL = os.getenv('REDIS_URL', 'redis://localhost:6379/0')
CHANNEL_USERNAME = "@tpgbit"  # –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –∫–∞–Ω–∞–ª –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏
BOT_USERNAME = "BitCurrencyBot"
redis_client = redis.Redis.from_url(REDIS_URL, decode_responses=True, ssl_cert_reqs="none")

if not TELEGRAM_TOKEN:
    logger.error("TELEGRAM_TOKEN not set")
    exit(1)
if not CRYPTO_PAY_TOKEN:
    logger.error("CRYPTO_PAY_TOKEN not set")
    exit(1)

AD_MESSAGE = "\n\nüì¢ –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ @tpgbit –¥–ª—è –Ω–æ–≤–æ—Å—Ç–µ–π –æ –∫—Ä–∏–ø—Ç–µ!"  # –°–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–∞–Ω–∞–ª–æ–º
FREE_REQUEST_LIMIT = 5  # –õ–∏–º–∏—Ç 5 –∑–∞–ø—Ä–æ—Å–æ–≤ –¥–ª—è –Ω–µ-–ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤
SUBSCRIPTION_PRICE = 5  # –¶–µ–Ω–∞ –ø–æ–¥–ø–∏—Å–∫–∏
CACHE_TIMEOUT = 5  # –í—Ä–µ–º—è –∫—ç—à–∞ –∫—É—Ä—Å–æ–≤
ADMIN_IDS = ["1058875848", "6403305626"]  # –ë–µ–∑–ª–∏–º–∏—Ç –¥–ª—è —ç—Ç–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
HISTORY_LIMIT = 10  # –õ–∏–º–∏—Ç –∏—Å—Ç–æ—Ä–∏–∏

# API endpoints (—Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
BINANCE_API_URL = "https://api.binance.com/api/v3/ticker/price"
WHITEBIT_API_URL = "https://whitebit.com/api/v1/public/ticker"

# –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –≤–∞–ª—é—Ç—ã (—Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
CURRENCIES = {
    'usd': {'code': 'USDT'},
    'uah': {'code': 'UAH'},
    'eur': {'code': 'EUR'},
    'rub': {'code': 'RUB'},
    'jpy': {'code': 'JPY'},
    'cny': {'code': 'CNY'},
    'gbp': {'code': 'GBP'},
    'kzt': {'code': 'KZT'},
    'try': {'code': 'TRY'},
    'btc': {'code': 'BTC'},
    'eth': {'code': 'ETH'},
    'xrp': {'code': 'XRP'},
    'doge': {'code': 'DOGE'},
    'ada': {'code': 'ADA'},
    'sol': {'code': 'SOL'},
    'ltc': {'code': 'LTC'},
    'usdt': {'code': 'USDT'},
    'bnb': {'code': 'BNB'},
    'trx': {'code': 'TRX'},
    'dot': {'code': 'DOT'},
    'matic': {'code': 'MATIC'}
}

# Fallback –∫—É—Ä—Å—ã (—Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
UAH_TO_USDT_FALLBACK = 0.0239
USDT_TO_UAH_FALLBACK = 41.84

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Redis
try:
    redis_client.ping()  # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Ä–∞–±–æ—Ç–∞–µ—Ç –ª–∏ Redis
    logger.info("Connected to Redis successfully")
except redis.ConnectionError as e:
    logger.error(f"Failed to connect to Redis: {e}")
    exit(1)

async def set_bot_commands(application: Application):
    """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–æ–º–∞–Ω–¥ —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫."""
    commands = [
        ("start", "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"),
        ("currencies", "–°–ø–∏—Å–æ–∫ –≤–∞–ª—é—Ç"),
        ("stats", "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"),
        ("subscribe", "–ü–æ–¥–ø–∏—Å–∫–∞"),
        ("alert", "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"),
        ("referrals", "–†–µ—Ñ–µ—Ä–∞–ª—ã"),
        ("history", "–ò—Å—Ç–æ—Ä–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤")
    ]
    try:
        await application.bot.set_my_commands(commands)
        logger.info("Bot commands set successfully")
    except TelegramError as e:
        logger.error(f"Failed to set bot commands: {e}")

async def check_subscription(update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ @tpgbit —Å –¥–µ—Ç–∞–ª—å–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º."""
    user_id = str(update.effective_user.id)
    try:
        chat_member = await context.bot.get_chat_member(CHANNEL_USERNAME, user_id)
        is_subscribed = chat_member.status in ['member', 'administrator', 'creator']
        logger.debug(f"User {user_id} subscription status: {is_subscribed} ({chat_member.status})")
        return is_subscribed
    except TelegramError as e:
        logger.error(f"Error checking subscription for {user_id}: {e}")
        await update.effective_message.reply_text(
            "‚ùå –ù–µ –º–æ–≥—É –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É. –£–±–µ–¥–∏—Å—å, —á—Ç–æ –±–æ—Ç ‚Äî –∞–¥–º–∏–Ω –≤ @tpgbit, –∏ –ø–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.",
            parse_mode=ParseMode.MARKDOWN
        )
        return False

async def enforce_subscription(update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
    """–û–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏ (—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –ª–æ–≥–∏–∫–∞)."""
    if await check_subscription(update, context):
        return True
    await update.effective_message.reply_text(
        "üö´ –ß—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º, –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ @tpgbit!\n–ü–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–≤—Ç–æ—Ä–∏ –∑–∞–ø—Ä–æ—Å.",
        parse_mode=ParseMode.MARKDOWN
    )
    return False

def save_stats(user_id: str, request_type: str):
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å TTL –¥–ª—è Redis."""
    try:
        stats = json.loads(redis_client.get('stats') or '{}')
        current_day = time.strftime("%Y-%m-%d")
        users = stats.setdefault("users", {})
        user_data = users.setdefault(user_id, {"requests": 0, "last_reset": current_day})
        
        if user_data["last_reset"] != current_day:
            user_data["requests"] = 0
            user_data["last_reset"] = current_day
        
        user_data["requests"] += 1
        stats["total_requests"] = stats.get("total_requests", 0) + 1
        stats["request_types"] = stats.get("request_types", {})
        stats["request_types"][request_type] = stats["request_types"].get(request_type, 0) + 1
        redis_client.setex('stats', 24 * 60 * 60, json.dumps(stats))  # –ö—ç—à –Ω–∞ 24 —á–∞—Å–∞
        logger.debug(f"Stats updated: {user_id} - {request_type}")
    except Exception as e:
        logger.error(f"Error saving stats: {e}")

def save_history(user_id: str, from_currency: str, to_currency: str, amount: float, result: float):
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —Å TTL."""
    try:
        history = json.loads(redis_client.get(f"history:{user_id}") or '[]')
        history = deque(history, maxlen=HISTORY_LIMIT)
        history.append({
            "time": time.strftime("%Y-%m-%d %H:%M:%S"),
            "from": from_currency,
            "to": to_currency,
            "amount": amount,
            "result": result
        })
        redis_client.setex(f"history:{user_id}", 30 * 24 * 60 * 60, json.dumps(list(history)))  # –ö—ç—à –Ω–∞ 30 –¥–Ω–µ–π
        logger.debug(f"History updated for {user_id}")
    except Exception as e:
        logger.error(f"Error saving history for {user_id}: {e}")

def check_limit(user_id: str) -> tuple[bool, str]:
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–∞ (—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ –¥–ª—è ADMIN_IDS)."""
    try:
        if user_id in ADMIN_IDS:  # –ë–µ–∑–ª–∏–º–∏—Ç –¥–ª—è 1058875848, 6403305626
            logger.debug(f"Admin {user_id} - unlimited access")
            return True, "‚àû"
        
        stats = json.loads(redis_client.get('stats') or '{}')
        if stats.get("subscriptions", {}).get(user_id, False):
            logger.debug(f"Subscribed user {user_id} - unlimited access")
            return True, "‚àû"
        
        users = stats.get("users", {})
        user_data = users.get(user_id, {"requests": 0, "last_reset": time.strftime("%Y-%m-%d")})
        remaining = FREE_REQUEST_LIMIT - user_data["requests"]
        logger.debug(f"User {user_id} has {remaining} requests left")
        return remaining > 0, str(remaining)
    except Exception as e:
        logger.error(f"Error checking limit: {e}")
        return False, "0"

def get_exchange_rate(from_currency: str, to_currency: str, amount: float = 1.0) -> tuple[float, float] | tuple[None, str]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫—É—Ä—Å–∞ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫."""
    from_key = from_currency.lower()
    to_key = to_currency.lower()
    cache_key = f"rate:{from_key}_{to_key}"
    
    cached = redis_client.get(cache_key)
    if cached:
        rate = float(cached)
        logger.info(f"Cache hit (real-time): {from_key} to {to_key} = {rate}")
        return amount * rate, rate
    
    from_data = CURRENCIES.get(from_key)
    to_data = CURRENCIES.get(to_key)
    if not from_data or not to_data:
        logger.error(f"Invalid currency: {from_key} or {to_key}")
        return None, "–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–∞—è –≤–∞–ª—é—Ç–∞"
    
    from_code = from_data['code']
    to_code = to_data['code']

    if from_key == to_key:
        rate = 1.0
        redis_client.setex(cache_key, CACHE_TIMEOUT, rate)
        return amount * rate, rate

    # Binance API —Å —Ç–∞–π–º–∞—É—Ç–æ–º –∏ –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫
    try:
        pair = f"{from_code}{to_code}"
        response = requests.get(f"{BINANCE_API_URL}?symbol={pair}", timeout=5).json()
        if 'price' in response:
            rate = float(response['price'])
            if rate <= 0:
                raise ValueError(f"Invalid Binance rate for {pair}: {rate}")
            logger.info(f"Binance direct rate (real-time): {pair} = {rate}")
            redis_client.setex(cache_key, CACHE_TIMEOUT, rate)
            return amount * rate, rate
    except (requests.RequestException, ValueError, KeyError) as e:
        logger.warning(f"Binance API failed for {from_key} to {to_key}: {e}")

    # WhiteBIT API —Å —Ç–∞–π–º–∞—É—Ç–æ–º –∏ –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫
    try:
        response = requests.get(WHITEBIT_API_URL, timeout=5).json()
        pair_key = f"{from_code}_{to_code}"
        if pair_key in response:
            rate = float(response[pair_key]['last_price'])
            if rate <= 0:
                raise ValueError(f"Invalid WhiteBIT rate for {pair_key}: {rate}")
            logger.info(f"WhiteBIT direct rate (real-time): {pair_key} = {rate}")
            redis_client.setex(cache_key, CACHE_TIMEOUT, rate)
            return amount * rate, rate
    except (requests.RequestException, ValueError, KeyError) as e:
        logger.warning(f"WhiteBIT API failed for {from_key} to {to_key}: {e}")

    # Fallback –¥–ª—è UAH-USDT
    try:
        if from_key == 'uah' and to_key == 'usdt':
            rate = UAH_TO_USDT_FALLBACK
            logger.info(f"Using fallback: {from_key} to {to_key} = {rate}")
            redis_client.setex(cache_key, CACHE_TIMEOUT, rate)
            return amount * rate, rate
        elif from_key == 'usdt' and to_key == 'uah':
            rate = USDT_TO_UAH_FALLBACK
            logger.info(f"Using fallback: {from_key} to {to_key} = {rate}")
            redis_client.setex(cache_key, CACHE_TIMEOUT, rate)
            return amount * rate, rate
        logger.error(f"No real-time rate found for {from_key} to {to_key}")
        return None, "–ö—É—Ä—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: –¥–∞–Ω–Ω—ã–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç"
    except Exception as e:
        logger.error(f"Fallback error: {e}")
        return None, "–ö—É—Ä—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞"

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–§—É–Ω–∫—Ü–∏—è —Å—Ç–∞—Ä—Ç–∞ —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º –æ—à–∏–±–æ–∫."""
    if not await enforce_subscription(update, context):
        logger.debug(f"User {update.effective_user.id} blocked by subscription")
        return
    user_id = str(update.effective_user.id)
    save_stats(user_id, "start")
    logger.info(f"User {user_id} started bot")
    
    keyboard = [
        [InlineKeyboardButton("üí± –ö–æ–Ω–≤–µ—Ä—Ç–µ—Ä", callback_data="converter"),
         InlineKeyboardButton("üìà –ö—É—Ä—Å—ã", callback_data="price")],
        [InlineKeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="stats"),
         InlineKeyboardButton("üíé –ü–æ–¥–ø–∏—Å–∫–∞", callback_data="subscribe")],
        [InlineKeyboardButton("üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è", callback_data="alert"),
         InlineKeyboardButton("üë• –†–µ—Ñ–µ—Ä–∞–ª—ã", callback_data="referrals")],
        [InlineKeyboardButton("üìú –ò—Å—Ç–æ—Ä–∏—è", callback_data="history")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    try:
        await update.effective_message.reply_text(
            "üëã *–ü—Ä–∏–≤–µ—Ç!* –Ø BitCurrencyBot ‚Äî —Ç–≤–æ–π –∏–¥–µ–∞–ª—å–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫ –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –≤–∞–ª—é—Ç –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏!\n"
            "üåü –í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∏–∂–µ –∏–ª–∏ –Ω–∞–ø–∏—à–∏ –∑–∞–ø—Ä–æ—Å (–Ω–∞–ø—Ä–∏–º–µ—Ä, \"usd btc\" –∏–ª–∏ \"100 uah usdt\").\n"
            f"üîë *–ë–µ—Å–ø–ª–∞—Ç–Ω–æ:* {FREE_REQUEST_LIMIT} –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ —Å—É—Ç–∫–∏.\n"
            f"üåü *–ë–µ–∑–ª–∏–º–∏—Ç:* /subscribe –∑–∞ {SUBSCRIPTION_PRICE} USDT.{AD_MESSAGE}",
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
    except TelegramError as e:
        logger.error(f"Error sending start message to {user_id}: {e}")

async def currencies(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–°–ø–∏—Å–æ–∫ –≤–∞–ª—é—Ç —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º –æ—à–∏–±–æ–∫."""
    if not await enforce_subscription(update, context):
        return
    currency_list = ", ".join(sorted(CURRENCIES.keys()))
    keyboard = [
        [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="start")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    try:
        await update.effective_message.reply_text(
            f"üí± *–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –≤–∞–ª—é—Ç—ã:*\n{currency_list}",
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
    except TelegramError as e:
        logger.error(f"Error sending currencies to {update.effective_user.id}: {e}")

async def alert(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫."""
    if not await enforce_subscription(update, context):
        return
    
    user_id = str(update.effective_user.id)
    args = context.args
    if len(args) != 3 or not args[2].replace('.', '', 1).isdigit():
        keyboard = [
            [InlineKeyboardButton("üîî USD ‚Üí BTC", callback_data="alert_example_usd_btc")],
            [InlineKeyboardButton("üîî EUR ‚Üí UAH", callback_data="alert_example_eur_uah")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="start")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        try:
            await update.effective_message.reply_text(
                "üîî *–ù–∞—Å—Ç—Ä–æ–π —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è!* –í–≤–µ–¥–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ: `/alert <–≤–∞–ª—é—Ç–∞1> <–≤–∞–ª—é—Ç–∞2> <–∫—É—Ä—Å>`\n"
                "–ü—Ä–∏–º–µ—Ä—ã –¥–æ—Å—Ç—É–ø–Ω—ã –Ω–∏–∂–µ:",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN
            )
        except TelegramError as e:
            logger.error(f"Error sending alert menu to {user_id}: {e}")
        return
    
    from_currency, to_currency, target_rate = args[0].lower(), args[1].lower(), float(args[2])
    if from_currency not in CURRENCIES or to_currency not in CURRENCIES:
        try:
            await update.effective_message.reply_text(
                "‚ùå –û—à–∏–±–∫–∞: –æ–¥–Ω–∞ –∏–∑ –≤–∞–ª—é—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è",
                parse_mode=ParseMode.MARKDOWN
            )
        except TelegramError as e:
            logger.error(f"Error sending currency error to {user_id}: {e}")
        return
    
    alerts = json.loads(redis_client.get(f"alerts:{user_id}") or '[]')
    alerts.append({"from": from_currency, "to": to_currency, "target": target_rate})
    redis_client.setex(f"alerts:{user_id}", 30 * 24 * 60 * 60, json.dumps(alerts))  # TTL –Ω–∞ 30 –¥–Ω–µ–π
    keyboard = [
        [InlineKeyboardButton("üîî –î–æ–±–∞–≤–∏—Ç—å –µ—â—ë", callback_data="alert"),
         InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="start")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    try:
        await update.effective_message.reply_text(
            f"üîî *–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ:* {from_currency.upper()} ‚Üí {to_currency.upper()} –ø—Ä–∏ –∫—É—Ä—Å–µ *{target_rate}*",
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
    except TelegramError as e:
        logger.error(f"Error sending alert confirmation to {user_id}: {e}")

async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º –æ—à–∏–±–æ–∫."""
    user_id = str(update.effective_user.id)
    if not await enforce_subscription(update, context):
        return
    
    stats = json.loads(redis_client.get('stats') or '{}')
    users = len(stats.get("users", {}))
    requests = stats.get("total_requests", 0)
    revenue = stats.get("revenue", 0.0)
    keyboard = [
        [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="start")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    try:
        if user_id in ADMIN_IDS:  # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤
            await update.effective_message.reply_text(
                f"üìä *–ê–¥–º–∏–Ω-—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:*\nüë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: *{users}*\nüìà –ó–∞–ø—Ä–æ—Å–æ–≤: *{requests}*\nüí∞ –î–æ—Ö–æ–¥: *{revenue} USDT*",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN
            )
        else:
            await update.effective_message.reply_text(
                f"üìä *–¢–≤–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:*\nüìà –ó–∞–ø—Ä–æ—Å–æ–≤ —Å–µ–≥–æ–¥–Ω—è: *{stats.get('users', {}).get(user_id, {}).get('requests', 0)}*",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN
            )
    except TelegramError as e:
        logger.error(f"Error sending stats to {user_id}: {e}")

async def subscribe(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–æ–¥–ø–∏—Å–∫–∞ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫."""
    if not await enforce_subscription(update, context):
        return
    
    user_id = str(update.effective_user.id)
    stats = json.loads(redis_client.get('stats') or '{}')
    if stats.get("subscriptions", {}).get(user_id, False):
        logger.info(f"User {user_id} already subscribed")
        try:
            await update.effective_message.reply_text(
                "üíé –¢—ã —É–∂–µ –ø–æ–¥–ø–∏—Å–∞–Ω!",
                parse_mode=ParseMode.MARKDOWN
            )
        except TelegramError as e:
            logger.error(f"Error sending subscription status to {user_id}: {e}")
        return
    
    headers = {'Crypto-Pay-API-Token': CRYPTO_PAY_TOKEN}
    payload = {
        "asset": "USDT",
        "amount": str(SUBSCRIPTION_PRICE),
        "description": f"–ü–æ–¥–ø–∏—Å–∫–∞ –¥–ª—è {user_id}"
    }
    try:
        response = requests.post("https://pay.crypt.bot/api/createInvoice", headers=headers, json=payload, timeout=15).json()
        logger.info(f"Invoice response for {user_id}: {json.dumps(response)}")
        if response.get("ok"):
            invoice_id = response["result"]["invoice_id"]
            pay_url = response["result"]["pay_url"]
            keyboard = [
                [InlineKeyboardButton(f"üí≥ –û–ø–ª–∞—Ç–∏—Ç—å {SUBSCRIPTION_PRICE} USDT", url=pay_url)],
                [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="start")]
            ]
            context.user_data[user_id] = {"invoice_id": invoice_id}
            try:
                await update.effective_message.reply_text(
                    f"üíé –û–ø–ª–∞—Ç–∏ *{SUBSCRIPTION_PRICE} USDT* –¥–ª—è –±–µ–∑–ª–∏–º–∏—Ç–∞:",
                    reply_markup=InlineKeyboardMarkup(keyboard),
                    parse_mode=ParseMode.MARKDOWN
                )
            except TelegramError as e:
                logger.error(f"Error sending payment message to {user_id}: {e}")
        else:
            logger.error(f"Invoice failed for {user_id}: {response}")
            await update.effective_message.reply_text(
                f"‚ùå –û—à–∏–±–∫–∞ –ø–ª–∞—Ç–µ–∂–∞: {response.get('error', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞')}",
                parse_mode=ParseMode.MARKDOWN
            )
    except requests.RequestException as e:
        logger.error(f"Subscribe error for {user_id}: {e}")
        await update.effective_message.reply_text(
            "‚ùå –û—à–∏–±–∫–∞ —Å–≤—è–∑–∏ —Å –ø–ª–∞—Ç–µ–∂–Ω–æ–π —Å–∏—Å—Ç–µ–º–æ–π",
            parse_mode=ParseMode.MARKDOWN
        )

async def referrals(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–†–µ—Ñ–µ—Ä–∞–ª—ã —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º –æ—à–∏–±–æ–∫."""
    if not await enforce_subscription(update, context):
        return
    user_id = str(update.effective_user.id)
    ref_link = f"https://t.me/{BOT_USERNAME}?start=ref_{user_id}"
    refs = len(json.loads(redis_client.get(f"referrals:{user_id}") or '[]'))
    keyboard = [
        [InlineKeyboardButton("üîó –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É", callback_data="copy_ref"),
         InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="start")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    try:
        await update.effective_message.reply_text(
            f"üë• *–¢–≤–æ—è —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞:* `{ref_link}`\n"
            f"üë§ –ü—Ä–∏–≥–ª–∞—à–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: *{refs}*\n"
            "üåü –ü—Ä–∏–≥–ª–∞—à–∞–π –¥—Ä—É–∑–µ–π –∏ –ø–æ–ª—É—á–∞–π –±–æ–Ω—É—Å—ã (—Å–∫–æ—Ä–æ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ)!",
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
    except TelegramError as e:
        logger.error(f"Error sending referrals to {user_id}: {e}")

async def history(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ò—Å—Ç–æ—Ä–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤ —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º –æ—à–∏–±–æ–∫."""
    if not await enforce_subscription(update, context):
        return
    user_id = str(update.effective_user.id)
    history = json.loads(redis_client.get(f"history:{user_id}") or '[]')
    if not history:
        keyboard = [
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="start")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        try:
            await update.effective_message.reply_text(
                "üìú *–ò—Å—Ç–æ—Ä–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤ –ø—É—Å—Ç–∞.*",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN
            )
        except TelegramError as e:
            logger.error(f"Error sending empty history to {user_id}: {e}")
        return
    
    response = "üìú *–ò—Å—Ç–æ—Ä–∏—è —Ç–≤–æ–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤:*\n"
    for entry in reversed(history):
        response += f"‚è∞ {entry['time']}: *{entry['amount']} {entry['from']}* ‚Üí *{entry['result']} {entry['to']}*\n"
    keyboard = [
        [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="start")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    try:
        await update.effective_message.reply_text(response, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
    except TelegramError as e:
        logger.error(f"Error sending history to {user_id}: {e}")

async def handle_referral(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤ —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º –æ—à–∏–±–æ–∫."""
    user_id = str(update.effective_user.id)
    args = context.args
    if len(args) == 1 and args[0].startswith("ref_"):
        referrer_id = args[0].replace("ref_", "")
        if referrer_id.isdigit():
            referrals = json.loads(redis_client.get(f"referrals:{referrer_id}") or '[]')
            if user_id not in referrals:
                referrals.append(user_id)
                redis_client.setex(f"referrals:{referrer_id}", 30 * 24 * 60 * 60, json.dumps(referrals))  # TTL –Ω–∞ 30 –¥–Ω–µ–π
                logger.info(f"New referral: {user_id} for {referrer_id}")
                try:
                    await update.effective_message.reply_text(
                        "üë• –¢—ã –±—ã–ª –ø—Ä–∏–≥–ª–∞—à—ë–Ω —á–µ—Ä–µ–∑ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É! –°–ø–∞—Å–∏–±–æ!",
                        parse_mode=ParseMode.MARKDOWN
                    )
                except TelegramError as e:
                    logger.error(f"Error sending referral message to {user_id}: {e}")

async def check_payment_job(context: ContextTypes.DEFAULT_TYPE):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∏ –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫."""
    try:
        if not hasattr(context, 'user_data') or not context.user_data:
            logger.debug("No user_data available in context, skipping payment check")
            return
        
        for user_id, data in list(context.user_data.items()):
            if "invoice_id" not in data:
                continue
            invoice_id = data["invoice_id"]
            headers = {'Crypto-Pay-API-Token': CRYPTO_PAY_TOKEN}
            try:
                url = f"https://pay.crypt.bot/api/getInvoices?invoice_ids={invoice_id}"
                response = requests.get(url, headers=headers, timeout=15).json()
                logger.info(f"Payment check for {user_id}: {json.dumps(response)}")
                if response.get("ok") and response["result"]["items"]:
                    status = response["result"]["items"][0]["status"]
                    if status == "paid":
                        stats = json.loads(redis_client.get('stats') or '{}')
                        stats.setdefault("subscriptions", {})[user_id] = True
                        stats["revenue"] = stats.get("revenue", 0.0) + SUBSCRIPTION_PRICE
                        redis_client.setex('stats', 30 * 24 * 60 * 60, json.dumps(stats))  # TTL –Ω–∞ 30 –¥–Ω–µ–π
                        del context.user_data[user_id]
                        logger.info(f"Payment confirmed for {user_id}")
                        try:
                            await context.bot.send_message(
                                user_id,
                                "üíé –û–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞! –£ —Ç–µ–±—è –±–µ–∑–ª–∏–º–∏—Ç.",
                                parse_mode=ParseMode.MARKDOWN
                            )
                        except TelegramError as e:
                            logger.error(f"Error sending payment confirmation to {user_id}: {e}")
            except requests.RequestException as e:
                logger.warning(f"Payment check failed for {user_id}: {e}")
    except Exception as e:
        logger.error(f"Payment check error: {e}")

async def check_alerts_job(context: ContextTypes.DEFAULT_TYPE):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–ª–µ—Ä—Ç–æ–≤ —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∏ –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫."""
    try:
        stats = json.loads(redis_client.get('stats') or '{}')
        for user_id in stats.get("users", {}):
            alerts = json.loads(redis_client.get(f"alerts:{user_id}") or '[]')
            if not alerts:
                continue
            updated_alerts = []
            for alert in alerts:
                from_currency, to_currency, target_rate = alert["from"], alert["to"], alert["target"]
                result, current_rate = get_exchange_rate(from_currency, to_currency)
                if result and current_rate <= target_rate:
                    from_code = CURRENCIES[from_currency]['code']
                    to_code = CURRENCIES[to_currency]['code']
                    try:
                        await context.bot.send_message(
                            user_id,
                            f"üîî *–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ!* –ö—É—Ä—Å *{from_code} ‚Üí {to_code}* –¥–æ—Å—Ç–∏–≥ *{current_rate:.8f}* (—Ü–µ–ª—å: {target_rate})",
                            parse_mode=ParseMode.MARKDOWN
                        )
                    except TelegramError as e:
                        logger.error(f"Error sending alert to {user_id}: {e}")
                else:
                    updated_alerts.append(alert)
            redis_client.setex(f"alerts:{user_id}", 30 * 24 * 60 * 60, json.dumps(updated_alerts))  # TTL –Ω–∞ 30 –¥–Ω–µ–π
            logger.debug(f"Checked alerts for user {user_id}")
    except Exception as e:
        logger.error(f"Alerts check error: {e}")

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫."""
    if not await enforce_subscription(update, context):
        logger.debug(f"User {update.effective_user.id} blocked by subscription")
        return
    
    user_id = str(update.effective_user.id)
    stats = json.loads(redis_client.get('stats') or '{}')
    is_subscribed = user_id in ADMIN_IDS or stats.get("subscriptions", {}).get(user_id, False)
    delay = 1 if is_subscribed else 5
    
    if 'last_request' in context.user_data and time.time() - context.user_data['last_request'] < delay:
        try:
            await update.effective_message.reply_text(
                f"‚è≥ –ü–æ–¥–æ–∂–¥–∏ {delay} —Å–µ–∫—É–Ω–¥{'—É' if delay == 1 else ''}!",
                parse_mode=ParseMode.MARKDOWN
            )
        except TelegramError as e:
            logger.error(f"Error sending delay message to {user_id}: {e}")
        return
    
    can_proceed, remaining = check_limit(user_id)
    if not can_proceed:
        try:
            await update.effective_message.reply_text(
                f"‚ùå –õ–∏–º–∏—Ç {FREE_REQUEST_LIMIT} –∑–∞–ø—Ä–æ—Å–æ–≤ –∏—Å—á–µ—Ä–ø–∞–Ω. –ü–æ–¥–ø–∏—à–∏—Å—å: /subscribe",
                parse_mode=ParseMode.MARKDOWN
            )
        except TelegramError as e:
            logger.error(f"Error sending limit exceeded message to {user_id}: {e}")
        return
    
    context.user_data['last_request'] = time.time()
    text = update.effective_message.text.lower()
    logger.info(f"Message from {user_id}: {text}")
    
    try:
        parts = text.split()
        if len(parts) < 2:
            raise ValueError("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤")
        if parts[0].replace('.', '', 1).isdigit():
            amount = float(parts[0])
            from_currency, to_currency = parts[1], parts[2]
            logger.debug(f"Parsed: amount={amount}, from={from_currency}, to={to_currency}")
        else:
            amount = 1.0
            from_currency, to_currency = parts[0], parts[1]
            logger.debug(f"Parsed: amount={amount}, from={from_currency}, to={to_currency}")
        
        save_stats(user_id, f"{from_currency}_to_{to_currency}")
        result, rate = get_exchange_rate(from_currency, to_currency, amount)
        if result is not None:
            from_code = CURRENCIES[from_currency.lower()]['code']
            to_code = CURRENCIES[to_currency.lower()]['code']
            remaining_display = "‚àû" if is_subscribed else remaining
            precision = 8 if to_code in ['BTC', 'ETH', 'XRP', 'DOGE', 'ADA', 'SOL', 'LTC', 'BNB', 'TRX', 'DOT', 'MATIC'] else 6
            keyboard = [
                [InlineKeyboardButton("üîÑ –ï—â—ë —Ä–∞–∑", callback_data=f"convert:{from_currency}:{to_currency}")],
                [InlineKeyboardButton("üí± –î—Ä—É–≥–∞—è –ø–∞—Ä–∞", callback_data="converter"),
                 InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="start")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            try:
                await update.effective_message.reply_text(
                    f"üí∞ *{amount:.1f} {from_code}* = *{result:.{precision}f} {to_code}*\n"
                    f"üìà –ö—É—Ä—Å: 1 {from_code} = *{rate:.{precision}f} {to_code}*\n"
                    f"üîÑ –û—Å—Ç–∞–ª–æ—Å—å –∑–∞–ø—Ä–æ—Å–æ–≤: *{remaining_display}*{AD_MESSAGE}",
                    reply_markup=reply_markup,
                    parse_mode=ParseMode.MARKDOWN
                )
            except TelegramError as e:
                logger.error(f"Error sending conversion result to {user_id}: {e}")
            save_history(user_id, from_code, to_code, amount, result)
        else:
            try:
                await update.effective_message.reply_text(
                    f"‚ùå –û—à–∏–±–∫–∞: {rate}",
                    parse_mode=ParseMode.MARKDOWN
                )
            except TelegramError as e:
                logger.error(f"Error sending error message to {user_id}: {e}")
    except Exception as e:
        logger.error(f"Message error for {user_id}: {e}")
        keyboard = [
            [InlineKeyboardButton("üí± –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞", callback_data="converter"),
             InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="start")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        try:
            await update.effective_message.reply_text(
                'üìù *–ü—Ä–∏–º–µ—Ä—ã:* `"usd btc"` –∏–ª–∏ `"100 uah usdt"`\n–ò–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π –º–µ–Ω—é —á–µ—Ä–µ–∑ /start',
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN
            )
        except TelegramError as e:
            logger.error(f"Error sending example message to {user_id}: {e}")

async def button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫ —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∏ –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫."""
    query = update.callback_query
    try:
        await query.answer(text="üåü –û–±—Ä–∞–±–æ—Ç–∫–∞... üåü", show_alert=True)
    except TelegramError as e:
        logger.error(f"Error answering callback for {query.from_user.id}: {e}")
    user_id = str(query.from_user.id)
    logger.debug(f"Processing callback: {query.data} for user {user_id}")
    
    if not await enforce_subscription(update, context):
        logger.debug(f"User {user_id} blocked by subscription")
        return
    
    stats = json.loads(redis_client.get('stats') or '{}')
    is_subscribed = user_id in ADMIN_IDS or stats.get("subscriptions", {}).get(user_id, False)
    delay = 1 if is_subscribed else 5
    
    if 'last_request' in context.user_data and time.time() - context.user_data['last_request'] < delay:
        try:
            await query.edit_message_text(
                f"‚è≥ –ü–æ–¥–æ–∂–¥–∏ {delay} —Å–µ–∫—É–Ω–¥{'—É' if delay == 1 else ''}!",
                parse_mode=ParseMode.MARKDOWN
            )
        except TelegramError as e:
            logger.error(f"Error sending delay message to {user_id} in button: {e}")
        return
    
    can_proceed, remaining = check_limit(user_id)
    if not can_proceed:
        try:
            await query.edit_message_text(
                f"‚ùå –õ–∏–º–∏—Ç {FREE_REQUEST_LIMIT} –∑–∞–ø—Ä–æ—Å–æ–≤ –∏—Å—á–µ—Ä–ø–∞–Ω. –ü–æ–¥–ø–∏—à–∏—Å—å: /subscribe",
                parse_mode=ParseMode.MARKDOWN
            )
        except TelegramError as e:
            logger.error(f"Error sending limit exceeded message to {user_id} in button: {e}")
        return
    
    context.user_data['last_request'] = time.time()
    action = query.data

    if action == "converter":
        keyboard = [
            [InlineKeyboardButton("üí∞ USD ‚Üí BTC", callback_data="convert:usd:btc"),
             InlineKeyboardButton("üí∂ EUR ‚Üí UAH", callback_data="convert:eur:uah")],
            [InlineKeyboardButton("‚Çø BTC ‚Üí ETH", callback_data="convert:btc:eth"),
             InlineKeyboardButton("‚Ç¥ UAH ‚Üí USDT", callback_data="convert:uah:usdt")],
            [InlineKeyboardButton("üîÑ –í–≤–µ—Å—Ç–∏ –≤—Ä—É—á–Ω—É—é", callback_data="manual_convert"),
             InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="start")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        try:
            await query.edit_message_text(
                "üí± *–í—ã–±–µ—Ä–∏ –≤–∞–ª—é—Ç–Ω—É—é –ø–∞—Ä—É –∏–ª–∏ –≤–≤–µ–¥–∏ –≤—Ä—É—á–Ω—É—é (–Ω–∞–ø—Ä–∏–º–µ—Ä, \"100 uah usdt\"):*",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN
            )
        except TelegramError as e:
            logger.error(f"Error sending converter menu to {user_id}: {e}")
    elif action == "price":
        try:
            await query.edit_message_text(
                "üìà *–í–≤–µ–¥–∏ –≤–∞–ª—é—Ç—É –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω—ã, –Ω–∞–ø—Ä–∏–º–µ—Ä: \"btc usd\"*",
                parse_mode=ParseMode.MARKDOWN
            )
        except TelegramError as e:
            logger.error(f"Error sending price prompt to {user_id}: {e}")
    elif action == "stats":
        users = len(stats.get("users", {}))
        requests = stats.get("total_requests", 0)
        revenue = stats.get("revenue", 0.0)
        keyboard = [
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="start")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        try:
            if user_id in ADMIN_IDS:  # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤
                await query.edit_message_text(
                    f"üìä *–ê–¥–º–∏–Ω-—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:*\nüë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: *{users}*\nüìà –ó–∞–ø—Ä–æ—Å–æ–≤: *{requests}*\nüí∞ –î–æ—Ö–æ–¥: *{revenue} USDT*",
                    reply_markup=reply_markup,
                    parse_mode=ParseMode.MARKDOWN
                )
            else:
                await query.edit_message_text(
                    f"üìä *–¢–≤–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:*\nüìà –ó–∞–ø—Ä–æ—Å–æ–≤ —Å–µ–≥–æ–¥–Ω—è: *{stats.get('users', {}).get(user_id, {}).get('requests', 0)}*",
                    reply_markup=reply_markup,
                    parse_mode=ParseMode.MARKDOWN
                )
        except TelegramError as e:
            logger.error(f"Error sending stats to {user_id}: {e}")
    elif action == "subscribe":
        try:
            await subscribe(update, context)
        except Exception as e:
            logger.error(f"Error processing subscribe for {user_id}: {e}")
    elif action == "alert":
        keyboard = [
            [InlineKeyboardButton("üîî USD ‚Üí BTC", callback_data="alert_example_usd_btc")],
            [InlineKeyboardButton("üîî EUR ‚Üí UAH", callback_data="alert_example_eur_uah")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="start")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        try:
            await query.edit_message_text(
                "üîî *–ù–∞—Å—Ç—Ä–æ–π —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è!* –í–≤–µ–¥–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ: `/alert <–≤–∞–ª—é—Ç–∞1> <–≤–∞–ª—é—Ç–∞2> <–∫—É—Ä—Å>`\n"
                "–ü—Ä–∏–º–µ—Ä—ã –¥–æ—Å—Ç—É–ø–Ω—ã –Ω–∏–∂–µ:",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN
            )
        except TelegramError as e:
            logger.error(f"Error sending alert menu to {user_id}: {e}")
    elif action == "referrals":
        ref_link = f"https://t.me/{BOT_USERNAME}?start=ref_{user_id}"
        refs = len(json.loads(redis_client.get(f"referrals:{user_id}") or '[]'))
        keyboard = [
            [InlineKeyboardButton("üîó –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É", callback_data="copy_ref"),
             InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="start")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        try:
            await query.edit_message_text(
                f"üë• *–¢–≤–æ—è —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞:* `{ref_link}`\n"
                f"üë§ –ü—Ä–∏–≥–ª–∞—à–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: *{refs}*\n"
                "üåü –ü—Ä–∏–≥–ª–∞—à–∞–π –¥—Ä—É–∑–µ–π –∏ –ø–æ–ª—É—á–∞–π –±–æ–Ω—É—Å—ã (—Å–∫–æ—Ä–æ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ)!",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN
            )
        except TelegramError as e:
            logger.error(f"Error sending referrals to {user_id}: {e}")
    elif action == "history":
        try:
            await history(update, context)
        except Exception as e:
            logger.error(f"Error processing history for {user_id}: {e}")
    elif action == "alert_example_usd_btc":
        try:
            await query.edit_message_text(
                "üîî –ü—Ä–∏–º–µ—Ä: `/alert usd btc 0.000015` ‚Äî —É–≤–µ–¥–æ–º–∏—Ç, –∫–æ–≥–¥–∞ 1 USD = 0.000015 BTC",
                parse_mode=ParseMode.MARKDOWN
            )
        except TelegramError as e:
            logger.error(f"Error sending USD-BTC alert example to {user_id}: {e}")
    elif action == "alert_example_eur_uah":
        try:
            await query.edit_message_text(
                "üîî –ü—Ä–∏–º–µ—Ä: `/alert eur uah 45.0` ‚Äî —É–≤–µ–¥–æ–º–∏—Ç, –∫–æ–≥–¥–∞ 1 EUR = 45 UAH",
                parse_mode=ParseMode.MARKDOWN
            )
        except TelegramError as e:
            logger.error(f"Error sending EUR-UAH alert example to {user_id}: {e}")
    elif action == "manual_convert":
        try:
            await query.edit_message_text(
                "üí± *–í–≤–µ–¥–∏ –∑–∞–ø—Ä–æ—Å –≤—Ä—É—á–Ω—É—é:* –Ω–∞–ø—Ä–∏–º–µ—Ä, \"100 uah usdt\"",
                parse_mode=ParseMode.MARKDOWN
            )
        except TelegramError as e:
            logger.error(f"Error sending manual convert prompt to {user_id}: {e}")
    elif action == "copy_ref":
        ref_link = f"https://t.me/{BOT_USERNAME}?start=ref_{user_id}"
        try:
            await query.answer(
                text=f"üåü –°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ: {ref_link} üåü",
                show_alert=True
            )
        except TelegramError as e:
            logger.error(f"Error answering copy_ref callback for {user_id}: {e}")
        refs = len(json.loads(redis_client.get(f"referrals:{user_id}") or '[]'))
        keyboard = [
            [InlineKeyboardButton("üîó –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É", callback_data="copy_ref"),
             InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="start")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        try:
            await query.edit_message_text(
                f"üë• *–†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞:* `{ref_link}`\n"
                f"üë§ –ü—Ä–∏–≥–ª–∞—à–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: *{refs}*\n"
                "üåü –ü—Ä–∏–≥–ª–∞—à–∞–π –¥—Ä—É–∑–µ–π –∏ –ø–æ–ª—É—á–∞–π –±–æ–Ω—É—Å—ã (—Å–∫–æ—Ä–æ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ)!",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN
            )
        except TelegramError as e:
            logger.error(f"Error sending referral link to {user_id}: {e}")
    elif action.startswith("convert:"):
        _, from_currency, to_currency = action.split(":")
        result, rate = get_exchange_rate(from_currency, to_currency)
        if result is not None:
            from_code = CURRENCIES[from_currency]['code']
            to_code = CURRENCIES[to_currency]['code']
            precision = 8 if to_code in ['BTC', 'ETH', 'XRP', 'DOGE', 'ADA', 'SOL', 'LTC', 'BNB', 'TRX', 'DOT', 'MATIC'] else 6
            keyboard = [
                [InlineKeyboardButton("üîÑ –ï—â—ë —Ä–∞–∑", callback_data=f"convert:{from_currency}:{to_currency}")],
                [InlineKeyboardButton("üí± –î—Ä—É–≥–∞—è –ø–∞—Ä–∞", callback_data="converter"),
                 InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="start")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            try:
                await query.edit_message_text(
                    f"üí∞ *1.0 {from_code}* = *{result:.{precision}f} {to_code}*\n"
                    f"üìà –ö—É—Ä—Å: 1 {from_code} = *{rate:.{precision}f} {to_code}*\n"
                    f"üîÑ –û—Å—Ç–∞–ª–æ—Å—å –∑–∞–ø—Ä–æ—Å–æ–≤: *{remaining}*{AD_MESSAGE}",
                    reply_markup=reply_markup,
                    parse_mode=ParseMode.MARKDOWN
                )
            except TelegramError as e:
                logger.error(f"Error sending conversion result to {user_id} in button: {e}")
            save_history(user_id, from_code, to_code, 1.0, result)
        else:
            try:
                await query.edit_message_text(
                    f"‚ùå –û—à–∏–±–∫–∞: {rate}",
                    parse_mode=ParseMode.MARKDOWN
                )
            except TelegramError as e:
                logger.error(f"Error sending error message to {user_id} in button: {e}")

if __name__ == "__main__":
    # –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º
    application = ApplicationBuilder().token(TELEGRAM_TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("currencies", currencies))
    application.add_handler(CommandHandler("alert", alert))
    application.add_handler(CommandHandler("stats", stats))
    application.add_handler(CommandHandler("subscribe", subscribe))
    application.add_handler(CommandHandler("referrals", referrals))
    application.add_handler(CommandHandler("history", history))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    application.add_handler(CallbackQueryHandler(button))

    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–¥–∞—á —Å –∏–º–µ–Ω–∞–º–∏ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    application.job_queue.run_repeating(check_payment_job, interval=60, name="check_payment")
    application.job_queue.run_repeating(check_alerts_job, interval=60, name="check_alerts")

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å TTL
    if not redis_client.exists('stats'):
        redis_client.setex('stats', 30 * 24 * 60 * 60, json.dumps({"users": {}, "total_requests": 0, "request_types": {}, "subscriptions": {}, "revenue": 0.0}))
    logger.info("Bot starting...")

    # –£–ª—É—á—à–µ–Ω–Ω—ã–π —Ü–∏–∫–ª polling —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏
    while True:
        try:
            application.run_polling(allowed_updates=Update.ALL_TYPES, drop_pending_updates=True)
        except NetworkError as e:
            logger.error(f"Network error: {e}. Retrying in 5 seconds...")
            time.sleep(5)
        except TelegramError as e:
            logger.error(f"Telegram error: {e}. Retrying in 5 seconds...")
            time.sleep(5)
        except Exception as e:
            logger.critical(f"Fatal error: {e}. Exiting...")
            exit(1)
